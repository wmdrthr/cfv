#[macro_use]
extern crate clap;
extern crate chrono;
extern crate walkdir;

use std::fs::{self, File};
use std::env;
use std::process::exit;
use std::path::PathBuf;

use clap::{Arg, App};
use chrono::Local;
use walkdir::WalkDir;
use data_encoding::HEXUPPER;

pub mod digest;

fn print_header() {

    let local_time = Local::now();

    println!("; Generated by {} v{} on {}",
             crate_name!(),
             crate_version!(),
             local_time.format("%Y-%m-%d at %H:%M:%S"));
}

fn process(path: PathBuf, tld: Option<&PathBuf>) {

    let metadata = match fs::metadata(&path) {
        Ok(m) => m,
        Err(e) => {
            eprintln!("{}: {} ", path.display(), e);
            return;
        }
    };

    if !metadata.is_file() {
        return;
    }

    let filename = if path.is_relative() {
        path.display()
    } else {
        match tld {
            Some(cwd) => path.strip_prefix(cwd).unwrap().display(),
            None => path.display()
        }
    };

    let file = match File::open(path.clone()) {
        Ok(f) => f,
        Err(_) => {
            eprintln!("{}: could not open file", filename);
            return;
        }
    };

    match digest::calculate_digest_mmap(file, digest::Digest::CRC32) {
        Ok(checksum) => { println!("{} {}", filename, HEXUPPER.encode(&checksum.to_be_bytes())); }
        Err(e) => { eprintln!("{}: {}", filename, e); }
    };
}

fn main() {

    let app = App::new(crate_name!())
        .version(crate_version!())
        .author(crate_authors!())
        .about(crate_description!())
        .arg(Arg::with_name("files")
             .multiple(true))
        .get_matches();

    print_header();

    if app.occurrences_of("files") == 0 {

        let current_dir = match env::current_dir() {
            Ok(p) => p,
            Err(_) => {
                eprintln!("Could not determine current directory");
                exit(3);
            }
        };

        for entry in WalkDir::new(&current_dir).min_depth(1) {
            process(entry.unwrap().path().to_path_buf(), Some(&current_dir));
        }

    } else {

        let iterator = app.values_of("files");
        for el in iterator.unwrap() {

            let path = PathBuf::from(el);
            for entry in WalkDir::new(&path)
                .min_depth(1)
                .contents_first(true) {
                    process(entry.unwrap().path().to_path_buf(), None);
            }
        }
    }
}
